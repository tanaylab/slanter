<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Analyzing meristems data • slanter</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Analyzing meristems data">
<meta property="og:description" content="slanter">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">slanter</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.2-0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/meristems.html">Analyzing meristems data</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="meristems_files/header-attrs-2.1/header-attrs.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Analyzing meristems data</h1>
                        <h4 class="author">Oren Ben-Kiki</h4>
            
            <h4 class="date">2020-08-13</h4>
      
      
      <div class="hidden name"><code>meristems.Rmd</code></div>

    </div>

    
    
<div id="the-problem" class="section level2">
<h2 class="hasAnchor">
<a href="#the-problem" class="anchor"></a>The Problem</h2>
<p>Suppose we have some data that compares some elements. Often this compares all the pairs of elements from some set, but sometimes pairs of elements from two different sets. In the concrete example used here, each element is a batch of ~1000 tomato meristem cells, which we have the combined RNA sequencing data for.</p>
<p>We want to visualize and understand the similarities between the elements. In our case, we have cell batches that we know were sampled at different times during a fast development process, and are interested in estimating how far along this process each batch is.</p>
<p>Naively, we can correlate the RNA profiles of the batches, getting a matrix where each entry tells us, for a specific pair of batches, how similar they are to each other. To get a non-negative similarity measure, we also change all negative correlation values to zero.</p>
<p>To load this <code>meristems</code> similarity matrix (and the <code>slanter</code> functions), write:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st">'slanter'</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="st">'meristems'</span><span class="op">)</span>
<span class="va">similarity</span> <span class="op">&lt;-</span> <span class="va">meristems</span>
<span class="va">similarity</span><span class="op">[</span><span class="va">similarity</span> <span class="op">&lt;</span> <span class="fl">0</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></code></pre></div>
<p>The next step would be to visualize this data. R helpfully gives us the <code>pheatmap</code> function, which will (by default) also cluster the data such that similar batches would be placed near each other. That is, in theory, we would not only get us a nice visualization, but we can hope to use this to obtain some meaningful order of the batches, which might map to a position along the development process we want to analyze.</p>
<p>So, we try:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">pheatmap</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/pheatmap/man/pheatmap.html">pheatmap</a></span><span class="op">(</span><span class="va">meristems</span>, show_rownames<span class="op">=</span><span class="cn">FALSE</span>, show_colnames<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span></code></pre></div>
<p><img src="meristems_files/figure-html/unnamed-chunk-2-1.png" width="700"></p>
<p>At a first glance, this seems to indicate there are two very sharply distinguished sub-groups of batches, with a third mixed group. We know the batches were sampled from a continuous process, and biological processes are never this clean. We definitely can’t use this to estimate the position of each batch along some development process.</p>
<p>Perhaps the problem is with the clustering? We could invoke <code>pheatmap</code> without any clustering at all. This would preserve the data’s order; if we had an a-priori order, this would be exactly what we’d need to do to visualize the data. However, in our case, there is no such a-priori order - it is exactly that which we are trying to extract from the data. That is, if we try:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">pheatmap</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/pheatmap/man/pheatmap.html">pheatmap</a></span><span class="op">(</span><span class="va">meristems</span>, show_rownames<span class="op">=</span><span class="cn">FALSE</span>, show_colnames<span class="op">=</span><span class="cn">FALSE</span>, cluster_rows<span class="op">=</span><span class="cn">FALSE</span>, cluster_cols<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span></code></pre></div>
<p><img src="meristems_files/figure-html/unnamed-chunk-3-1.png" width="700"></p>
<p>This most definitely is <em>not</em> what we want to see.</p>
<p>So, what went wrong? It turns out, our the data is fine. The problem is with the method we used to visualize/analyze it.</p>
<p>To understand the root problem, consider a hierarchical clustering algorithm given the numbers <code>1, 2, 3, 4</code> to cluster. We expect it to group the two low values together, then the two high values, and combine them to a final <code>( (1, 2), (3, 4) )</code> tree. In practice, however, such algorithms don’t care about the internal order within each tree node. That is, the algorithm would be just as happy giving us the tree <code>( (4, 3), (1, 2) )</code>, which is technically correct, but is not the best kind of correct.</p>
<p>Amplify this problem to hundreds, or thousands, of clustered elements, and it is obvious in retrospect that we can’t expect <code>hclust</code> (and therefore <code>pheatmap</code>) to solve our problem. Enter “slanted matrices” to the rescue.</p>
</div>
<div id="slanted-matrices" class="section level2">
<h2 class="hasAnchor">
<a href="#slanted-matrices" class="anchor"></a>Slanted Matrices</h2>
<p>Technically, a “slanted matrix” is a matrix which is reordered such that its highest values are as close to the diagonal as possible. This, in theory, should give us a clearer indication of the overall structure of the similarity data. Ignoring clustering for a moment, we therefore try:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/sheatmap.html">sheatmap</a></span><span class="op">(</span><span class="va">meristems</span>, order_data<span class="op">=</span><span class="va">similarity</span>, show_rownames<span class="op">=</span><span class="cn">FALSE</span>, show_colnames<span class="op">=</span><span class="cn">FALSE</span>, cluster_rows<span class="op">=</span><span class="cn">FALSE</span>, cluster_cols<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span></code></pre></div>
<p><img src="meristems_files/figure-html/unnamed-chunk-4-1.png" width="700"></p>
<p><strong>This is exactly the same data as before.</strong></p>
<p><em>Implementation notes:</em></p>
<p>Internally, this is implemented by the <code>slanted_orders</code> function, which repeatedly sorts the rows by the index of their “center of mass” column, and then the columns by the index of their “center of mass” row, until the system stabilizes. This is pretty fast for small data (e.g. up to N=1000 batches as in here) but grows (roughly) at a rate of (N log N)^2, so it may take a long while when ordering several thousands of elements. That said, displaying a heatmap with many thousand rows and columns isn’t very practical anyway.</p>
<p>This is not restricted to the square symmetric matrix one gets from computing correlations. It will also work just as well for a rectangular or an asymmetric similarity matrix.</p>
<p>The <code>sheatmap</code> function wraps all this (with additional functionality described below), similarly to the way <code>pheatmap</code> wraps the unordered <code>hclust</code> functionality.</p>
<p>The similarity data used for reordering must contain only non-negative values. Here we are showing correlation data, which can be negative. To overcome this we have chosen to set all negative correlation to zero, and we use the <code>order_data</code> which allows displaying the original (possibly negative) data while ordering by another (non-negative) data. Clustering (described below) is always done on the original data.</p>
</div>
<div id="reordered-clustering" class="section level2">
<h2 class="hasAnchor">
<a href="#reordered-clustering" class="anchor"></a>Reordered Clustering</h2>
<p>What if we still want to see the cluster structure of our data? The <code>sheatmap</code> function provides two main options to do this, with different trade-offs.</p>
<p>If we have an a-priori clustering of the data, we can pass it to <code>sheatmap</code> (in the same way as we pass it to <code>pheatmap</code>, e.g. <code>cluster_rows=hclust(...)</code>). In this case, <code>sheatmap</code> will preserve the clustering, but at each node will pick the best order of the two sub-trees so that the end result will be the “best” slanted order.</p>
<p>That is, if we again consider the “technically correct” clustering tree <code>( (4, 3), (1, 2) )</code>, and the ideal order <code>1, 2, 3, 4</code>, then <code>sheatmap</code> will use the <code>reorder_hclust</code> function to give us the equivalent clustering tree <code>( (1, 2), (3, 4) )</code>. In general, however, one can’t always get exactly the ideal order; <code>reorder_hclust</code> does the best it can.</p>
<p>We don’t have an a-priory clustering, but we did get one from <code>pheatmap</code> (that is, <code>hclust</code>). We might reasonably assume the only problem is not with that tree as of itself, but just with the fact it is essentially in a random order. Assuming all this, we can ask <code>sheatmap</code> to use the same <code>hclust</code> as <code>pheatmap</code>, and merely reorder it for improved visualization, by writing:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/sheatmap.html">sheatmap</a></span><span class="op">(</span><span class="va">meristems</span>, order_data<span class="op">=</span><span class="va">similarity</span>, show_rownames<span class="op">=</span><span class="cn">FALSE</span>, show_colnames<span class="op">=</span><span class="cn">FALSE</span>, oclust_rows<span class="op">=</span><span class="cn">FALSE</span>, oclust_cols<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span></code></pre></div>
<p><img src="meristems_files/figure-html/unnamed-chunk-5-1.png" width="700"></p>
<p>Better - we do see there’s a transition between two states, but it is more blocky than the smooth transition we have seen before, which seems a better fit for the continuous biological process we wish to capture.</p>
<p>Still, in some cases the unconstrained <code>hclust</code> clustering might be superior, or we may have some other a-priori clustering we wish to preserve. In such cases, this approach would allow us to visualize this clustering in the “best possible” way.</p>
</div>
<div id="ordered-clustering" class="section level2">
<h2 class="hasAnchor">
<a href="#ordered-clustering" class="anchor"></a>Ordered Clustering</h2>
<p>The default behavior for <code>sheatmap</code> is to use <code>oclust</code> instead of <code>hclust</code>, that is generate a clustering tree which is constrained to be compatible with the “ideal” slanted order. Thus, we can replace the simple use of <code>pheatmap</code> with the simple use of <code>sheatmap</code>:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/sheatmap.html">sheatmap</a></span><span class="op">(</span><span class="va">meristems</span>, order_data<span class="op">=</span><span class="va">similarity</span>, show_rownames<span class="op">=</span><span class="cn">FALSE</span>, show_colnames<span class="op">=</span><span class="cn">FALSE</span><span class="op">)</span></code></pre></div>
<p><img src="meristems_files/figure-html/unnamed-chunk-6-1.png" width="700"></p>
<p>Much better - here we not only the see the clear gradient as before, but also that it splits naturally to a few phases (that smoothly transition from one to the next). We can highlight this by using the <code>cutree</code> flags:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/sheatmap.html">sheatmap</a></span><span class="op">(</span><span class="va">meristems</span>, order_data<span class="op">=</span><span class="va">similarity</span>, show_rownames<span class="op">=</span><span class="cn">FALSE</span>, show_colnames<span class="op">=</span><span class="cn">FALSE</span>, cutree_rows<span class="op">=</span><span class="fl">5</span>, cutree_cols<span class="op">=</span><span class="fl">5</span><span class="op">)</span></code></pre></div>
<p><img src="meristems_files/figure-html/unnamed-chunk-7-1.png" width="700"></p>
<p><em>Implementation notes:</em></p>
<p>Internally, this is implemented by the <code>oclust</code> function.</p>
<p>In general hierarchical clustering of elements (rows or columns in our case) tries to create a binary tree such that the more similar two elements are, the closer they are in the tree. The twist in ordered clustering (as implemented by <code>oclust</code>) is that the elements are ordered, and each group of elements clustered under any tree node must be a contiguous range of such elements.</p>
<p>Visually this means that if we draw the final clustering tree on top of the ordered elements, there would be no edge crossings. This makes ordered clustering a natural addition to the slanted matrix visualization.</p>
<p>That is, normally (as in <code>pheatmap</code>), an unconstrained hierarchical clustering is done first, and the matrix visualization order is chosen to be compatible with the clustering tree. Here (in <code>sheatmap</code> using <code>oclust</code>), we do the opposite - we first order the elements for the slanted matrix visualization, and then find a compatible clustering tree to go with it.</p>
<p>In principle it is possible to adapt any clustering method to include an ordering constraint. We chose to adapt <a href="https://en.wikipedia.org/wiki/Ward%27s_method">Ward’s method</a> (both <code>ward.D</code> and the default <code>ward.D2</code> are supported). In this method, the algorithm starts with each element on its own, and merges the two elements such that the total variance within the merged node is minimized. It recursively merges groups of elements (minimizing the variance each time) until obtaining the full clustering tree.</p>
<p>The general Ward’s method can pick any two element groups to combine at each step. In contrast, the ordered <code>oclust</code> variant can only choose adjacent element groups, trusting the a-priori order to have placed similar elements adjacent to each other. This makes the algorithm much faster, which allows for a practical pure R implementation. The full Ward’s method is slower, so requires a FORTRAN implementation.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Oren Ben-Kiki.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
